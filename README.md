# CS-230-Operating-Platforms

**Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?**
The client, The Gaming Room, wanted to expand their existing game Draw It or Lose It into a web-based application that could be played on multiple devices and operating systems. They needed software that would allow multiple teams and players to participate in real time while ensuring each game and team name remained unique.

Their main requirements included creating a single active game instance, managing team and player data securely, supporting simultaneous users, and maintaining cross-platform compatibility. The goal was to design a scalable, secure, and responsive web application that followed modern software development and security best practices to deliver a smooth and accessible gaming experience.

**What did you do particularly well in developing this documentation?
**
In developing this documentation, I did particularly well in translating the client’s needs into clear technical requirements and designing a solution that addressed both functionality and performance. I made sure the document was well-structured and easy to follow, allowing readers to understand how each design choice supported the client’s goals.

I also excelled in applying software design principles effectively—using inheritance, encapsulation, and the singleton pattern to ensure efficiency and data integrity. My analysis of the different operating platforms was thorough and balanced, showing a strong understanding of how each environment would impact development and deployment.

Overall, I did a great job of creating a comprehensive, professional, and technically sound document that not only met the project criteria but also demonstrated thoughtful planning and real-world applicability.

**What about the process of working through a design document did you find helpful when developing the code?**

Working through the design document was helpful because it forced me to plan out the structure and logic of the program before diving into the actual coding. By mapping out the classes, their relationships, and the system’s requirements, I was able to see how all the parts would fit together and interact. This made it easier to design code that was organized, reusable, and easy to maintain.

The process also helped me think critically about key design choices, such as how to implement the singleton pattern, handle unique identifiers, and manage multiple teams and players efficiently. Having these details documented early meant fewer surprises during development and smoother problem-solving when translating the design into working code.

**If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?**

If I could revise one part of my work on these documents, I would focus on the Requirements section. While it clearly listed the main system needs, I think it could be improved by adding more detailed functional and non-functional requirements to give a fuller picture of what the software must accomplish.

To improve it, I would separate the requirements into clear categories such as gameplay functions, user interactions, system performance, and security standards. I’d also include measurable criteria—for example, specifying response times for real-time actions or limits on concurrent users—to make the requirements more testable and objective.


**How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?**

I interpreted the user’s needs by focusing on their goals for accessibility, performance, and security, then translating those into design features like unique identifiers, the singleton pattern, and a responsive web interface. Considering user needs is vital because it ensures the software is functional, intuitive, and aligned with real-world use, leading to better user satisfaction and overall project success.

**How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?**

I approached the software design by first identifying the client’s goals and requirements, then creating a clear plan that outlined the system’s structure, classes, and data flow before coding. I used object-oriented design principles and architectural planning to ensure the solution was scalable, secure, and easy to maintain.

In the future, I would continue using strategies like requirement analysis, UML modeling, prototyping, and iterative testing to better visualize system interactions and catch issues early. These techniques help create efficient, user-focused software that meets both technical and business needs.
